<!DOCTYPE html>
<html lang="zh_CN">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
//基本类型
var mood = "happy",age = 23;
mood = "happy"
mood = 22;
mood = 33.25;
mood = ture;
alert(mood);


//数组
var arr = Array();

arr = Array(4);

arr[0] = 'John';
arr[1] = 33;
arr[2] = 33.25;
arr[3] = true;

arr = Array("John",33,33.25,true);

arr = ["John",33,33.25,true];

//关联数组
arr = Array();
arr["name"] = "John";
arr["year"] = 33;
arr["living"] = true;


//对象
var san = Object();
san.name =  "zwsanc";
san.year = 1994;
san.living = true;
//另一种语法-花括号
san = {};
san = {name:"zwsanc",year:1994,living:ture};
san.length;//数组长度属性

//数组关联对象
var ts = Array();
ts[0] = san;
ts[0].name;//等于zwsanc

//对象关联对象
ts = {};
ts.san = san;
ts.san.name;//等于zwsanc


//if 中的"==="全等比较符
if(""){}//fasle
if(false == ""){}//true
if(false === ""){}//fasle
if("1" = 1){}//true
if("1" === 1){}//fasle


// 函数
function say(){
	alert('hello!');
}
say();

function mul(num1,num2){
	alert(num1*num2);
}

// JS中使用调用函数的位置只要在全局变量声明之后便可以使用该全局变量
// 但是函数调用可以在函数声明之前.这点跟java相同
say2();
function say2(){
	if(temp == undefined){
		alert("1");
	}else{
		alert(temp);
	}
}
var temp = "I'm a employee.";
say2();


// 对象进阶-属性与方法
person.mood;
person.age;

person.talk();
person.walk();

// js中对象分为三种:1.內建对象(native object) 2.宿主对象(host object) 3.用户定义对象(user-defined object)
// 1.內建对象
var carr = new Array();
carr.length;//对象属性

// Math对象与Date对象
alert(Math.round(10));//随机0~10
var current_date = new Date();
current_date.getDay();
current_date.getHours();
current_date.getMonth();

// Global对象
Global.isNaN();
Global.parseInt();
Global.eval();
Global.Number();



// 宿主对象 由运行环境(浏览器)提供的预定义对象.
// window,screen等

// DOM(document object model)对象,是宿主对象window的子对象.
// window.document进行访问.
// HTML文档采用的是子级标签法,所以可以展示成树形结构图.
// DOM Element-可以为元素节点或者是下级的文本节点,文本节点,注释节点等.
// DOM Attribute-Element的属性.
// DOM Event-Element的事件




// 用户对象
var person = {...};





// JS代码在使用时最好是DOM树加载完成时,当浏览器生成DOM树后会调用window.onload事件.
// 多次访问DOM树会造成页面响应速度的下降,尽可能的减少节点的标记(id,class等)可以提升DOM树在遍历时的速度.

// JS脚本尽可能的写在js文件中通过外联的方式访问,而不是内嵌在html文档中(尽可能的做好分离).
// 当JS脚本有多个时,推荐合并成一个以减少http请求数.

// 写完的js脚本要压缩可以减少不少的体积.jquery.min.js.

a.onclick = function{
	alert('aaa');
}
$('a').click(function(){
	alert('aaa');
});

// 页面的重要内容应该一开始便放在文档中,而不是通过js动态加载,这样搜索引擎才能更容易爬到.

// abbr标签可以起到提示的作用

// js从DOM获得信息的方法
getElementById();
getElementByTagName();
getAttribute();

// js向DOM添加信息
createElement();
createTextNode();
appendChild();
insertBefore();
setAttrbute();

// html的三位一体
// -html
// 	结构层(html)-文档基本结构.文档的结构要尽量简单,层级要少,element要少.
// 	表现层(css)-页面样式,色彩,风格,视觉效果.
// 	行为层(js)-用户行为响应.

//每一层起着不同的作用,尽可能不要通过js直接修改页面样式(通过style属性),而是通过修改element的class属性来进行样式变更.

// js的平稳退化,指js在低版本浏览器上也可以正常的展示,至少不破坏页面交互.

// CND服务(Content Delevery Network,内容分发网络),将第三方js库托管至第三方服务器,在引用第三方js库时使用公共URL路径,用户在访问时,CDN跟根据用户所在的地理位置找到距离用户最近的服务器提供相应文件.


/*********下面是js进阶教程*********/
/*********下面是js进阶教程*********/
/*********下面是js进阶教程*********/

// 一个完整的JavaScript应该由三个部分构成:
// 1.核心(ECMAScript)
// 2.文档对象(DOM)
// 3.浏览器对象(BOM)

// ECMA(European Computer Manufactures Association,欧洲计算机制造联合会)制定了标准化的JavaScript实现,称为EMCAScript.以后各个浏览器制造商都要按照这个标准实现.
// W3C(World Wide Web Consortium,万维网联盟)制定了标准化的DOM结构.
DOM级别
DOM level 1:DOM Core和DHTML组成,DOM Core心规定的是如何映射基于 XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在 DOM 核心的基础上加以扩展，添加了针对 HTML 的对象和方法。
DOM level 2:DOM2在DOM1的基础上扩充了-鼠标和用户界面事件,范围,遍历等模块.通过对象接口增加了对CSS的支持.
DOM2新增模块:
-DOM Views:定义了跟踪不同文档视图的接口(例如,应用css前后的文档).
-DOM Events:定义了事件和事件处理接口.
-DOM Style:定义了基于css为元素应用样式的接口.
-DOM 遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口。

----Script标签
script的两个属性:
	async-异步脚本,表示应该立即下载脚本,但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。
	defer-延迟脚本,表示应该立即下载脚本,但可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效.

只要不存在 defer 和 async 属性，浏览器都会按照<![CDATA[<script>]]>元素在页面中出现的先后顺序对它们依次进行解析。


script与img标签都可以通过src属性访问页面所在域之外的某个域中的文件(例如CDN服务).

----head 与 body标签.
如果将js,css文件引用放在head标签中,意味着必须等到全部的代码被下载/解析和执行完成,才能开始呈现内容.
因为浏览器在读取到body标签后才会在浏览器上显示内容.

故,一般都将js文件放在body标签最后(css文件则需要放在head标签内,元素在呈现时必须显示正确的样式).

----浏览器是如何解析HTML文件的.(具体信息请搜索:HTML解析原理)
从上到下依次解析,执行到script标签时,会通过src路径下载js文件
(
	期间会一直处于阻塞状态,如果script标签使用了async属性,则不再阻塞浏览器异步执行该脚本.
	如果script标签使用了defer属性,还是会阻塞直到js文件被下好,然后不执行js脚本,在文档被加载完成后才会执行.
),
执行完js文件中的代码后才会继续向下执行.

----js的严格模式,"use strict";在函数内部第一行,或是js文件第一行添加该代码.

----js全局变量的三种声明方式:
1.js脚本内部:var a = 5;该变量在该脚本内部的任意位置(声明位置之后)都可以调用.
2.函数内部:(应该杜绝的声明方式)
function say(){
	a = 3;//该变量为全局变量-在严格模式下会出现异常.
	var b = 5;//局部变量,函数结束后会销毁.
}
3.使用window全局对象声明(全局对象的属性对应也是全局变量)
window.test = 50;
jquery1.5代码最后一段:window.jQuery = window.$ = jQuery;

*如果不是万不得已，最好不要使用全局变量。


----ECMAScript的数据类型
	五种基本数据类型:Undefined,Null,boolean,number,string(字面量赋值).
	引用数据类型:Object,Array,Boolean,Date,Math,Number,String,RegExp,Function,Event

----typeof返回值
	undefined-值未定义
	boolean-值为布尔
	string-值为字符串
	number-值为数字
	object-值为对象或null
	function-值为函数

----instanceof
if(person instanceof Object) 
var person = new Object(); =>true;
var person = null; =>true;
var person = 5; => false;


----六种类型的if判断
1.undefined
var a;--变量a以声明未赋值 所以 typeof的结果为 undefined.
if(a) => fasle;
if(a == undefined) => true;

2.null
var a = null;--typeof 结果为object
if(a) => fasle;
if(a == null) => true;
if(a == undefined) => true;--undefined是null派生的.
if(a === undefined) => false;--undefined与null是不同的基本类型.

3.boolean
var a = true;
if(a) => a;

4.String
var a = '';
if(a) => false;
if(a == '') => true;
if(a == null) => false; --null是object类型使用的
if(a === '') => true;
if(a === null) => false;--string与null不是同一个基本类型.

5.Number
var a = +-0;
if(a) => false;
if(a == '') => true;
if(a == '0') => true;
if(a == null) => false; --null是object类型使用的
if(a === '') => false; --基本类型不同




----关于一些顶级函数的说明.
1.isNaN
if(NaN) => false;
if(NaN == NaN) => false;--任何涉及到NaN的运算(四则运算和逻辑运算)都会返回NaN

isNaN(1|'1'|true|false|null) => false;
isNaN('blue'|undefined) =>true;

2.parseInt
var num1 = parseInt("1234blue"); // 1234
var num2 = parseInt(""); // NaN
var num3 = parseInt("0xA"); // 10（十六进制数）
var num4 = parseInt(22.5); // 22
var num5 = parseInt("070"); // 56（八进制数）
var num6 = parseInt("70"); // 70（十进制数）
var num7 = parseInt("0xf"); // 15（十六进制数）

3.parseFloat
var num1 = parseFloat("1234blue"); //1234 （整数）
var num2 = parseFloat("0xA"); //0
var num3 = parseFloat("22.5"); //22.5
var num4 = parseFloat("22.34.5"); //22.34
var num5 = parseFloat("0908.5"); //908.5
var num6 = parseFloat("3.125e7"); //31250000

4.String()
var value1 = 10;
var value2 = true;
var value3 = null;
var value4;
alert(String(value1)); // "10"
alert(String(value2)); // "true"
alert(String(value3)); // "null"
alert(String(value4)); // "undefined"

alert(value1.toString()); // "10"
alert(value2.toString()); // "true"
alert(value3.toString()); // 没有返回值
alert(value4.toString()); // 没有返回值

以下关于js操作符,变量,类型的比较以及常用函数,类型转换就不再描述.

----js for-in语句.
for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。
for (var propName in window) { //迭代window对象的全部属性名.不一定就是顺序(非ArrayList)输出.
	document.write(propName);
}

----label,break,continue关键字,参考java.

----with语句.大量使用with语句会使性能下降,并且严格模式下无法使用with语句,所以不推荐使用.
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;
<==>
with(location){
	var qs = search.substring(1);
	var hostName = hostname;
	var url = href;
}


----js的function
function sayHi(name,message){
	return ; // 'return ;'的返回值为undefined.
	alert('Hello '+name+','+message); // return后面的代码不会被执行.规范化的函数应当只有一个出口和入口.
}

函数的参数,实际上JS函数并不介意声明函数时所声明的参数个数.实际上js底层是通过arguments对象来封装函数传参的.
我们能通过arguments[x]的形式来访问参数,即使不声明函数参数.

例如:
function sayHi(){
	alert('Hello '+arguments[0]+','+arguments[1]);
}
或:
function sayHi(name){ // 命名的参数只提供便利，但不是必需的
	alert('Hello '+name+','+arguments[1]);
}
sayHi('san','how are you today?');

其实arguments.length属性可以获得参数数量,该对象只是与Array对象类似,但他并不是数组实例.

因为js function 没有返回标识与传参声明标识(函数/方法签名),导致该语言无法拥有重载特性,相同命名的函数后面的会覆盖前面的.


----js的变量(object)
变量可以为基本类型或引用类型.

这点跟java相似,在存储基本类型时存储的是值,存储引用类型时存储的是对象在堆内存中的引用.所以引用变量的赋值操作会将引用赋值过去.
var person = new Object();
var san = person;
person.name = 'san';
alert(san.name); => san.

跟java不同的是,在js中string为基本类型.

----js变量执行环境.
执行环境(execution context)与java的变量作用域概念类似.
执行环境分为两种:
全局执行环境(web浏览器中,全局执行环境被认为是window对象,因此所有全局变量和函数都是作为window对象的属性和方法创建的,当网页或浏览器被关闭时,全局执行环境才会被销毁.)
局部执行环境(函数内部,局部执行环境中的代码执行完毕后,该环境会被销毁,保存在其中的所有变量和函数定义也随之销毁.)

当代码在一个环境中执行时,会创建变量对象的一个作用域链(scope chain),作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。

例如: 子执行环境可以调用父执行环境的变量.反之不行.
var a = 1;
function sayHi(){
	var b = 2;
	function sayHii(){
		var c = 3;
		alert(b); // 
	}
	sayHii();
}
window
	-a
	sayHi
		-b
		sayHii
			-c
			-alert(b)
变量寻找会自下而上依次查询.



----js没有块级作用域概念,在if,for,while等代码块中生成的变量在当前函数中可以正常访问.
if (true) {
	var color = "blue";
}
alert(color); //"blue"


----js垃圾回收机制
1.标记清除法-当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。回收器会间隔性的回收标记为'离开环境'的变量所引用的堆内存
2.引用计数法-记录每个对象(堆内存地址)的被引用次数,当被引用次数为0时,自动销毁该对象(堆内存).
	引用计数因为循环引用所带来的弊端被标记清除法所取代.
循环引用:
function problem(){
	var objectA = new Object();
	var objectB = new Object();
	objectA.someOtherObject = objectB;
	objectB.anotherObject = objectA;
}


----js引用类型
1.Object
-初始化
var person = new Object(); <==> var person = {}; //与 new Object()相同
person.name = "Nicholas"; <==> person['name'] = "Nicholas"; // 代码作用相同
person.age = 29;
-字面量初始化
var person = {
	name : "Nicholas",
	age : 29,
	5 : true // 数字会自动转换为字符串.
};

-字面量传参
function sayHi(person){
	alert(person.name+','+person.age);
}
sayHi({
	name:'san',
	age:23
}); // 太6了.


person.name = "Nicholas"; <==> person['name'] = "Nicholas"; // 代码作用相同
或是
var propertyName = 'name';
person[propertyName] = 'san'; --有点像java中的反射操作.


2.Array类型,js的数组是不限定数组类型的,数组长度是动态的.
var name = new Array(); <==> name = Array(); <==> name = []; //代码作用相同

name[name.length] = 'san'; // 在数组末尾插入新变量.
name.length = 5; // 如果数组长度低于5,则新增至5,用undefined插入.反之则只保留前5个变量.

----转化方法
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
alert(colors.toString()); // red,blue,green
alert(colors.valueOf()); // red,blue,green
alert(colors); // red,blue,green
alert(colors.join("||")); //red||green||blue

----数组,栈
js-Array类型提供了栈的方法.push,pop;
var colors = new Array(); // 创建一个数组
var count = colors.push("red", "green"); // 推入两项
alert(count); //2
count = colors.push("black"); // 推入另一项
alert(count); //3
var item = colors.pop(); // 取得最后一项
alert(item); //"black"
alert(colors.length); //2

----数组,队列,shift,unshift.
var colors = new Array(); //创建一个数组
var count = colors.push("red", "green"); //推入两项
alert(count); //2
count = colors.push("black"); //推入另一项
alert(count); //3
var item = colors.shift(); //取得第一项
alert(item); //"red"
alert(colors.length); //2

unshift方法可以在队列开头插入变量,与pop一同使用可以实现反向队列.


----数组重排序,reverse(反转数组),sort(将数组中的值toString后排序.)

var values = [0, 1, 5, 10, 15];
values.sort();
alert(values); //0,1,10,15,5

-
function compare(value1, value2) {
	if (value1 < value2)
		return -1;
	else if (value1 > value2)
		return 1;
	else
		return 0;
}
var values = [0, 1, 5, 10, 15];
values.sort(compare); // 传入方法.
alert(values); //0,1,5,10,15


----Array其他api-1.concat,2.slice,3.indexOf,4.lastIndexOf,5.every,6.filter,7.forEach,8.map,9.some,10.reduce,11.reduceRight


3.Date类型,没什么好说的,自己去查API.

4.RegExp类型,正则表达式类型,详情自己去看文档.
Boolean,Number,String,Math自己去看文档.

5.Funtion类型,js中最有意思的类型,而有意思的根源，则在于函数实际上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。
函数对象的三种声明方式:
function sum (){ // 函数声明式
	return arguments[0]+arguments[1];
}
<==>
var sum = function(){ // 变量赋值式
	return arguments[0]+arguments[1];
};
<==>
var sum = new Function('return arguments[0]+arguments[1]'); // 不推荐,这种语法会导致解析两次代码,从而影响性能
var sum = new Function('a','b','return a+b'); 

函数可以作为传参.
function domethod(method,property){ // 传入需要执行函数与属性,与java反射差不多
	method(property);
}
var sayHi = function(name){ // 定义函数
	alert('Hi '+name+' , how are you today?');
};
domethod(sayHi,'san');

匿名函数传参.碉堡了.666
domethod(function(name){
	alert('Hi '+name+' , how are you today?');
},'san');

想想jquery不就是这样的么!
$(function(){...});

'函数声明式'与'变量赋值式'初始化函数的区别!
js解析器在正式执行代码之前会先预读一遍代码,将其中的函数提取出来将它们放在源代码顶部,但'变量赋值式'则不会.

alert(sum(10,10)); //不会报错
function sum(num1, num2){ 
	return num1 + num2;
}

alert(sum(10,10)); //报错
var sum = function(num1, num2){ 
	return num1 + num2;
};


----返回值为函数

function createComparisonFunction(propertyName) { // 根据对象的不同属性,返回不同的排序方式.
	return function(object1, object2){
		var value1 = object1[propertyName];
		var value2 = object2[propertyName];
		if (value1 < value2){
			return -1;
		} else if (value1 > value2){
			return 1;
		} else {
			return 0;
		}
	};
}
var data = [{name: "Zachary", age: 28}, {name: "Nicholas", age: 29}];
data.sort(createComparisonFunction("name"));
alert(data[0].name); //Nicholas
data.sort(createComparisonFunction("age"));
alert(data[0].name); //Zachary


----函数的两个属性.arguments,this
在函数内部，有两个特殊的对象： arguments 和 this。其中， arguments 
它是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，
但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。
function factorial(num){
	if (num <=1) {
		return 1;
	} else {
		return num * arguments.callee(num-1)
	}	
}

this.this引用的是函数执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时，this 对象引用的就是 window）
--或者说,this是函数所从属的对象(变量).

window.color = "red";
var o = { color: "blue" };
function sayColor(){
	alert(this.color);
}
sayColor(); //"red"
o.sayColor = sayColor;
o.sayColor(); //"blue"


----函数的length,property属性,sayHi.length=>sayHi函数声明的传参个数.property属性后面说明.

----函数的apply(),call()方法,两个方法的调用方式略微有点不同,但执行结果都是相同的.其目的都是让行为(函数)与主体(对象)解耦.

var name = 'gobal';
var person = {name:'san'};
function say(){
	alert(this.name); // this.name 表示调用函数当前执行环境下名为name的变量.
}
say(); -- gobal.当前函数的执行环境是全局环境,this所代表的对象是window,name属性指的便是window.name.=gobal

person.say = say;
person.say(); -- san.当前函数的执行环境是局部环境,this代表的对象是person.

--上面使用this的方式,让方法在不同的环境下有不同的输出.也就是说随着方法this的对象的改变,方法会获得不同输出.从而实现方法与对象的解耦
--上面的方法中 person.say = say; 意味着将say函数的this指向person对象.

而apply,call方法则封装了这一步.
say.call(this); --gobal.
say.call(person); --san.
var car = {name:'benz'};
say.call(car); --benz.

call与apply方法还可以传参.



----顶级函数,eval();
js解析器在执行到eval函数时,会将eval代码插入当前行,然后执行插入的语句.通过 eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。




-----js面向对象设计.
ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”

var person = new Object();
person.name = "Nicholas";
person.age = 29;
person.job = "Software Engineer";
person.sayName = function(){
	alert(this.name);
};

var person = {
	name: "Nicholas",
	age: 29,
	job: "Software Engineer",
	sayName: function(){
		alert(this.name);
	}
};

var person = {name:'san',age:23};
delete person.name; --delete 可以删除对象的属性
alert(person.name);	--undefined

----ECMAScript 中有两种属性：数据属性和访问器属性。特性比较超前部分老版浏览器只实现了部分,详情见文档157页


----对象的两种模板化创建方式
1.工厂模式.
function createPerson(name, age, job){
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function(){
		alert(this.name);
	};
	return o;
}
var person = createPerson('san',23,'Software Engineer');

createPeroson函数还可以简写-
function createPerson(name, age, job){
	return {
		name:name,
		age:age,
		job:job,
		sayName:function(){alert(this.name);}
	};
}


2.构造函数模式. 以构造模式定义的函数(Person)是定义在window对象(全局环境)中的.在各个地方都能调用.而工厂方式则只是普通函数.
function Person(name, age, job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = function(){
		alert(this.name);
	};
}
var person = new Person('san',23,'Software Engineer');
if(person.constructor == Person) => true;  //对象的constructor属性最初是用来标识对象类型的
if(person.constructor == Object) => false;
if(person instanceof Person) => true;
if(person instanceof Object) => true;


Person('san',23,'Software Engineer');--不添加修饰符new,是将该对象(堆内存)中的属性,添加到对应执行环境中.比如window

var p = {other:'hi'};
Person.call(p,'san',23,'Software Engineer');--通过call方法可以将对象(堆内存)中的属性,添加到该对象中.
p.sayName();

弊端,每次创造对象时,sayName函数便会跟着创建一次(开辟内存地址,java有方法区所以方法都是通用的).造成性能浪费
解决方法,将方法拿出来写在当前执行环境上.
function Person(name, age, job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = sayName;
}
function sayName(){
	alert(this.name);
}
var a = new Person('san',23,'Software Engineer');
var b = new Person('san',23,'Software Engineer');
if(a.sayName == b.sayName) =>true,引用的方法都是同一个.


----JS原型对象(property) 重点!!!
----JS原型对象(property) 重点!!!

1.每个函数都有prototype属性,该属性指向prototype对象.
	可以通过:函数名.prototype.属性名 = xxx;的方式来给该函数的prototype对象添加属性.

2.构造函数创建的对象也存在prototype属性(内部属性),该属性指向的正是构造函数prototype属性. 
	所以prototype对象是构造函数以及该构造函数创建的所有对象共享的.  --就像java类中的成员变量和成员方法.

3.prototype对象存在constructor属性,该属性指向该prototype所在的函数.
	也就是说 Person == Person.prototype.constructor;

4.prototype对象只能由,函数名.prototype来添加/修改/删除属性.
	delete Person.prototype.name; (虽然对象也能获得prototype对象,但是只拥有读权限.)

5.实例对象内部属性与对象的prototype对象的属性名重复的话,会覆盖掉prototype对象内部属性.
	san.name,san.prototype.name.

6.实例对象的prototype属性指向prototype对象,而不是构造函数.

7.原生引用对象的prototype属性.所有原生引用类型（Object、 Array、 String，等等）都在其构造函数的原型上定义了方法。
	Array.prototype.sort;String.prototype.substring;
	可以给原生对象添加新的方法(但不推荐这样做):String.prototype.startsWith = function(text){return this.indexOf(text) == 0;};



function Person(){
	if(arguments.length != 0)
			this.name = arguments[0];
}

Person.prototype.name = 'san';
Person.prototype.age = 23;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function(){alert(this.name);};
<==>
Person.prototype = {
	constructor: Person, //以字面量形式创建prototype对象,会导致constructor属性指向Object对象而不是自己的函数对象.不过此时的constructor属性已经变成可枚举类型.
	name: 'san',
	age: 23,
	job: 'Software Engineer',
	sayName: function(){
		alert(this.name);
	}
};

//注意:该方法 IE9以下浏览器以及老版浏览器不支持.
Object.defineProperty(Person.prototype,'constructor'{ //将constructor属性的可枚举类型设置为false
	enumerable:false,
	value:Person
});


var san = new Person();
var li = new Person('Li');

----in 操作符.判断对象是否拥有该属性(不管该属性是否在prototype对象中).
if('name' in san) => true; --来自原型
if('name' in li) => true;  --来自对象

----hasOwnProperty函数,判断对象是否拥有该属性(只会校验对象内部属性,跟prototype对象无关)
if(san.hasOwnProperty('name')) =>false;
if(li.hasOwnProperty('name')) =>true;

----keys函数,以数组的形式返回对象所有属性名.(部分浏览器支持)
Object.keys(Person.prototype); --name,age,job,sayName
Object.keys(san);  --实例对象没有定义属性
Object.keys(li);  --name
Object.keys(san.prototype); --实例对象不能这样访问原型对象.

----getOwnPropertyNames函数与keys作用一致,返回对象全部属性(包括不可枚举类型的),(部分浏览器支持)
Object.getOwnPropertyNames(Person.prototype); ----constructor,name,age,job,sayName


----原型的动态性,原型对象的任何修改会立刻在实例对象中反应出来.
Person.prototype.age = 33;
alert(san.age); --33
Person.prototype.sayHi = function(){alert('Hi');};
san.sayHi(); --Hi


----重写prototype对象.
Person.prototype = {
	age = 99;
};
alert(san.age); --33

var test = new Person();
alert(test.age); --99
alert(test.name); --undefined

-构造函数重写了prototype对象,实际上等于重新开辟了一块堆内存,引用发生了改变.而实例对象中的引用还指向原来的prototype对象.


----prototype对象的缺点.
-当prototype对象中的值为引用类型时,例如Array;
Person.prototype.friends:['tom','susan'];

-该引用类型中的某个字段被实例对象,修改后会立刻反应到全部实例对象上.类似java里多线程造成的成员变量数据污染.
alert(san.friends);
san.friends[2] = 'bob';
alert(li.friends);

-当然这正是你所期望的结果那么便不算缺点.
-从这里可以看出,prototype对象中适合定义常量或是全局参数,函数等.
-将对象的内部(自有)变量放在构造函数中定义,将常量/全局参数/函数等放入prototype中定义.混合模式.


----动态原型模式,将原型初始化放在构造函数中.
function Person(){
	if(arguments.length != 0)
		this.name = arguments[0];
	if(this.name == undefined) //可以根据不同参数来选择不同的prototype初始化.达到一种同一个类的分化效果.
		Person.prototype.name = 'haha';
}

-这种方式的缺点,prototype不能使用字面量方式初始化.因为prototype对象在每个对象被构造出来后才会赋值,如果用字面量初始化会重置prototype对象的引用指针.


----寄生构造模式与稳妥构造模式.(说是构造函数其实跟构造函数没关系.跟prototype更没关系,只是用来通过函数创建对象的手段,与工厂模式类似)
*寄生构造模式
function Person(name, age, job){
	return {
		name:name,
		age:age,
		job:job,
		sayName:function(){alert(this.name);}
	};
}
var friend = new Person("Nicholas", 29, "Software Engineer"); //与工厂模式的区别是前面加了new 修饰符.实际上根本没有Person这个引用类型(instanceof Person),Person只是函数名.

-这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。
function SpecialArray(){
	//创建数组
	var values = new Array();
	//添加值
	values.push.apply(values, arguments);
	//添加方法
	values.toPipedString = function(){
		return this.join("|");
	};
	//返回数组
	return values;
}
var colors = new SpecialArray("red", "blue", "green");
alert(colors.toPipedString()); //"red|blue|green

*稳妥构造模式-跟上个模式区别:1.构造方式中不使用this关键字,2.创建实例时不使用new关键字.
function Person(name, age, job){
	return {
		name:name,
		age:age,
		job:job,
		sayName:function(){alert(name);}//不使用this关键字,name值在实例对象构造时被确定了下来,之后都不会修改.
	};
}
var friend = Person("Nicholas", 29, "Software Engineer"); 
friend.sayName(); //Nicholas
friend.name = 'friend';
friend.sayName(); //Nicholas -不会因为变量的修改而改变.

var test = {name:'test'};
test.sayName = friend.sayName;
test.sayName(); //Nicholas


----继承 重点!!!
----继承 重点!!!
-OO语言中继承分为接口继承(implements)与实现继承(extends).implements继承方法签名,extends继承实际的方法.因为js并不存在方法签名所以只能extends(依靠原型链).
*原型链
function A(){
	this.name = 'a';
}
A.prototype.getName = function(){
	return this.name;	
};
A.prototype.sayHi = function(){
	alert('Hi');
}
function B(){
	this.age = 23;
}
B.prototype = new A();//继承
B.prototype.getName = function(){//重写父类方法
	return 'b';
}

var test = new B();
alert(test.getName());//b -重写的方法
alert(test.name);//a -从原型链上继承的属性
test.sayHi();//Hi -从原型链上继承的属性(方法)

alert(test.prototype instanceof A); //true
alert(test.prototype instanceof B); //true
alert(test.prototype instanceof Object); //true

alert(B.prototype instanceof A); //true
alert(B.prototype instanceof B); //false 
alert(B.prototype instanceof Object); //true


-在寻找属性时,1.寻找当前实例内部属性,2.寻找prototype(父类实例)内部属性,3.寻找父类实例prototype属性.
-原型链的最末端是Object prototype.所有引用类型的顶级父类都是Object(所有函数的默认原型都是Object实例).

*原型链实现原型的弊端!!!
*原型链实现原型的弊端!!!
*原型链实现原型的弊端!!!
function A(){
	this.colors = ["red", "blue", "green"];
}
function B(){}
B.prototype = new A();//继承.多个B类型的实例对象,会继承自同一个A类型的实例对象,这样A实例对象内部的引用属性会被所有B类型实例共享.

var s1 = new B();
alert(s1.colors);//red,blue,green
s1.colors.push('black');
var s2 = new B();
alert(s2.colors);//red,blue,green,black


----借用构造函数,可以避免原型链的问题.借用构造函数与原型链一起使用的方式叫做组合继承.
function A(name){
	this.colors = ["red", "blue", "green"];
	this.name = name;
}
A.prototype.sayNmae = function(){alert(this.name);};
function B(name){
	A.call(this,name); //借用A的构造函数.将A构造函数内的属性赋予自身.
}

B.prototype = new A();
B.prototype.constructor = B; //将prototype指向子类构造函数.
var b = new B('b');


----原型式继承,原型链实现的extends的简单变形封装罢了.不必预先定义构造函数的情况下实现继承
function object(o){  //将子类的定义,原型赋值,创造子类对象放在一个函数中.
	function F(){}; //定义子类
	F.prototype = o; //原型赋值
	return new F(); //创造子类对象
}
var person = {
	name: "Nicholas",
	friends: ["Shelby", "Court", "Van"]
};
var anotherPerson = object(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");

var yetAnotherPerson = object(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");

alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"


----寄生继承.基于原型继承.使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。
function object(o){  //将子类的定义,原型赋值,创造子类对象放在一个函数中.
	function F(){}; //定义子类
	F.prototype = o; //原型赋值
	return new F(); //创造子类对象
}

function createAnother(o){
	var clone = object(o); //通过调用函数创建一个新对象(原对象的子类对象)
	clone.sayHi = function(){ //以某种方式来增强子类对象,行为增强.
		alert("hi");
	};
	return clone; //返回子类对象
}


----寄生组合继承.弥补了组合继承的不足,也弥补了寄生继承的弊端(组合继承会调用两次父类构造函数,降低性能.寄生继承子类),日哦,这么多继承方式
function object(o){  //将子类的定义,原型赋值,创造子类对象放在一个函数中.
	function F(){}; //定义子类
	F.prototype = o; //原型赋值
	return new F(); //创造子类对象
}

function inheritPrototype(Sub, Super){ //构造函数.
	var prototype = object(Super.prototype); //创建对象
	prototype.constructor = Sub; //增强对象
	Sub.prototype = prototype; //指定对象
}

function A(){}
A.prototype.sayName = function(){alert('123');};
function B(){
	A.call(this);
}
inheritPrototype(B,A);
var b = new B();
b.sayName();

--组合继承中子类的prototype关联的是父类的实例,实例中自然包含了父类的全部属性(成员属性-prototype,内部属性-构造函数中定义的).
B.prototype = new A();
--而组合继承中的借用构造函数中call(又回调了父类的构造函数).
A.call(this);--每个子类实例又获得一般父类的全部属性(成员属性-prototype,内部属性-构造函数中定义的).

--寄生组合继承中,将父类prototype属性赋值给空对象的prototype属性,给prototype指定constructor属性,然后赋予子类的prototype属性
说白了,之前(组合继承)是将父类实例赋予子类prototype属性(所以会调用两次父类构造函数).
现在(寄生组合继承)是直接将父类的prototype包装进空白类,然后赋予给子类.这样省掉了调用父类构造函数的代码.



----函数表达式
----函数表达式
*函数表达式?递归?闭包?

-函数的两种声明方式
1.表达式声明
function sayHi(){
	alert('Hi!');
}
2.匿名函数式声明(拉姆达函数)
var sayHi = function(){
	alert('Hi!');
}

js解析器会在执行代码前,先读取一遍js代码,将表达式声明的函数通过'函数声明提升'的方式将此函数代码放到js代码块最开始部位.而匿名函数则不会.
所以:这种写法是错误的.
if(condition){
	function sayHi(){
		alert("Hi!");
	}
} else {
	function sayHi(){
		alert("Yo!");
	}
} 

//可以这样做
var sayHi;
if(condition){
	sayHi = function(){
		alert("Hi!");
	};
} else {
	sayHi = function(){
		alert("Yo!");
	};
} 


-递归,由于js语法的特性,函数也是对象.
function factorial(num){
	if (num <= 1){
		return 1;
	} else {
		return num * factorial(num-1);
	}
}
var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4)); //出错！

-通过之前写的,使用arguments.callee可以保存每次调用自身.
-但arguments.callee在严格模式下会报错.这里建议使用匿名函数写法.

var factorial = (function f(num){ //外部无法访问f函数.
	if (num <= 1){
		return 1;
	} else {
		return num * f(num-1);
	}
});



与其告诉你这个技术是做什么的,倒不如告诉你为什么需要这个技术.
----闭包,重点!!!
----闭包,重点!!!
----闭包,重点!!!
闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数.
闭包的五种写法.

//第1种写法  
function Circle(r) {  
      this.r = r;  
}  
Circle.PI = 3.14159;  
Circle.prototype.area = function() {  
  return Circle.PI * this.r * this.r;  
}  
var c = new Circle(1.0);     
alert(c.area());  




----new修饰符的作用!!!
----new修饰符的作用!!!
----new修饰符的作用!!!


--以上代码创建了名为Circle的类,并为该类设置了名为PI的变量(此变量不是实例共享的).还为该类设置了静态属性(area函数,各个实例共享).
--circle的原型(prototype)对象,由circle的prototype变量名引用.而原型对象中引用了Circle函数的r与PI属性.
--根据js回收机制:如果一个对象未被引用,则销毁该对象(并销毁该对象内部的全部对象).如果两个对象互相引用却并未其他对象引用则销毁这两个对象.
--如果只是调用:Circle(5);-函数.那么在this.r=r;这样代码执行完后,该函数便会被销毁(全部内部对象).

--但调用:var c = new Circle(1.0)后.new修饰符会先生成一个函数的副本然后返回这个副本的引用(注意不是原函数的引用).然后把'1.0'作为参数执行该副本.
--this.r=r;等于给当前副本添加了一个属性.

--关于new,如果函数结束时没有return语句,或是return ;或是return 1|1.5|'123'|true等基本类型.
--这种情况在var ct = new FunctionName(5);时,js解析器会进行三部操作.
--1.var ct = {};创建名为ct的空对象.
--2.在堆中复制FunctionName对象的另一个实体(将该实体的prototype指向原实体的prototype),然后让ct指向该实体.
--3.执行副本代码,把5传进去.由于该实体被引用,所以该实体下所有属性都不会被销毁.

--如果函数结束时存在return语句,并且返回的是引用类型,例如:{}-空对象,[]-空数组,function(){}-空函数.
--则js解析器会进行另外的操作.
--会将5带入函数并执行,将返回的引用类型赋予变量ct,而ct.prototype指向的是Object(所有对象的顶级prototype).
--原函数内的所有对象因为该函数执行环境的结束而被销毁,而返回的引用类型例外,因为它正被其它变量所引用.

--总之使用了new修饰符,是一定会返回引用类型的,如果不是return所返回的,那么就是该函数自身的副本引用.



//第2种写法  
var Circle = function() {
    var obj = new Object();  
    obj.PI = 3.14159;  
    obj.area = function(r) {  
    	return this.PI * r * r;
    }
    return obj;  
}  
var c = new Circle(); //返回的是obj对象.
alert( c.area(3) );  


//第3种写法  
var Circle = function(){};  
Circle.PI = 3.14159;  
Circle.Area = function( r ) {
       return this.PI * r * r;  
}
alert( Circle.Area( 1.0 ) );
var c = new Circle();//变量c没有任何内部对象除了(prototype,指向Circle的prototype)

Circle.PI;--静态属性,只能通过类名直接调用.
Circle.Area(1.0);--静态方法,只能通过类名直接调用.
--其实,这是因为PI,Area只是属于Circle对象的两个子对象罢了,而通过new是无法得到的.因为new相当于执行了一遍Circle函数

var Circle = function(){
	var t = 5;
	this.s = 6;
	this.c = 12;
	this.sc = this.s+this.c;
	this.add = function(){
		alert(t+this.s);
	};

	function sub(){
		add();
	};
	sub(); //undefined 
};
var c = new Circle();
c.t // error --函数内部var修饰的变量(不管是基本类型还是引用类型),作用域只在函数内部(函数内部一个属性).而不能作为函数的一个属性
c.s // 6 --this修饰的变量作为函数属性.
c.add(); //s is not defined --


js中变量的四种类型.
1.内部属性(方法).在函数内部以var修饰的属性(方法),这些属性在函数外部是无法访问的.
--或是说函数的实例对象是无法访问的(通过new创建的对象),这些属性可以被这些属性调用(函数内var属性被函数内var方法调用)
--这些属性(方法)也可以被成员属性(方法)调用.

2.成员属性(方法).在函数内部以this修饰的属性(方法),可以获得内部属性进行运算,可以被this修饰的属性(方法)使用(在使用时要添加this表示调用的是成员属性).
--注意!!! 内部属性(方法)不能调用成员属性(方法),调用成员属性会出现undefined,调用成员方法会显示is not defined.

3.共有属性(方法),prototype对象内的属性(方法).prototype上的属性(引用类型:对象与函数)是成员们(类的每个实例)共享的.一般prototype对象中存放方法(达到类似java中方法区的概念.如果方法放在函数内部用this修饰则每次new的新对象都会存在这个方法的副本).
--共有属性是实时的,修改后会立即反应在每个实例上.
--注意!!! prototype是实现继承的基本方式(原型继承-核心概念,让子类的prototype指向父类实例).

----继承::
--原型继承的缺点,因为prototype中的属性是共有属性,所以全部子类的实例都会使用共有的父类实例(因为子类的prototype指向的是父类实例).
--为了解决原型继承的缺点,我们可以使用构造函数的方式来实现.
--在子类构造函数中使用SuperClassName.call(this)的方式,重新创建父类对象,并将父类对象的属性添加到当前执行环境,来覆盖掉prototype对象中共有的父类实例属性.
--因为原型链在引用时,是先找当前执行环境下的属性,没有再去找当前执行环境下prototype中的属性,如果还是没有就找prototype中prototype的属性.

--将原型继承(B.prototype = new A();)和借用构造函数(A.call(this);)结合起来便是使用次数最多的继承方式--组合继承!
--组合继承的缺点:原型继承时会创建一次父类实例,每次借用构造函数时也会创建一次父类实例.
--使用另一种方式可以避免这种现象--寄生组合式继承.
--将父类的prototype属性,赋予一个空对象的prototype然后,将该空对象赋予子类的prototype属性.这样既免去了实例化父类的麻烦又能保持原型链的结构一致.
--另一种方法(直接让子类prototype等于父类prototype,缺点原型链结构不一致,但是在isPrototypeOf,instanceof判断下结构与寄生模式是一致的).
--将(B.prototype = new A(); --改为: B.prototype = A.prototype;区别在于,前者子类的prototype指向的是父类的实例,后者子类prototype指向的是父类prototype).


4.类(静态)属性(方法),A.PI=3.14159;A.AREA = function(r){this.PI*r*r};类属性(方法)在创建实例时不会被获得这些属性.
--类属性(方法)中引用的变量不加this表示只引用当前执行环境下的属性(全局属性与外部属性).
--加this,只会引用类属性
--如果加this并且使用了 A.AREA.call(a),则会按顺序引用a对象的成员属性/共有属性.

var PI = '全局属性';
function Circle(){
	var PI = '内部属性';
	this.PI = '成员属性';
}  
Circle.PI = '类属性';  
Circle.prototype.PI = '共有属性'; 
Circle.Area = function() {
       console.log(this.PI);  
}
Circle.Area();//类属性,只会显示类属性,如果类属性为空,则显示undefined.
Circle.Area.call(new Circle());//成员属性,如果成员属性为空则显示共有属性.两个都为空显示undefined

//不加this,变量的值是,当前执行环境下的值.ha()--'外部属性'(如果没有外部属性就是全局属性),Circle.Area();--'全局属性'
//不会寻找类属性/共有属性/成员属性/内部属性.


js解析器优先执行顺序:内部属性>成员属性>共有属性>类属性






function A(name){this.name = name;}
function B(name){
	A.call(this,name);
}
A.prototype.sayName = function(){console.log(name);}
B.prototype = A.prototype;
var b = new B('san');


B.prototype = new A();
函数的两种声明方式,函数声明提升,匿名函数(拉姆达函数)




<script type="text/javascript" charset="utf-8">


function Person(){    
    var name = "default";
    this.getName = function(){    
        return name;    
    },    
    this.setName = function(newName){    
        name = newName;    
    }
}
var p = new Person(); 
//返回一个person对象,该对象有两个对象(也可以说是函数:getName,setName),这两个属性中引用了外部变量name,该对象的prototype就是Person的prototype,prototype.constructor指向Person()函数.
//可以简化为:
function Person(){
	var name = "default";
	this.sayName = function(){
		alert(name);
	}
	return {
		getName:function(){
			return name;
		},
		setName:function(newName){
			name = newName;
		}
	};
}
//返回一个匿名对象,这个对象的prototype是匿名类的prototype,指向object.没有prototype.constructor属性.
//sayName对象是无法获得的.可以改成:
function Person(){
	var name = "default";
	var sayName = function(){
		alert(name);
	}
	return {
		getName:function(){
			return name;
		},
		setName:function(newName){
			name = newName;
		},
		sayName:sayName //可以访问.
	};
}


</script>

</body>
</html>